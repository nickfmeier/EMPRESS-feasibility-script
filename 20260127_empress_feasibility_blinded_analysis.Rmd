---
title: "EMPRESS analysis script"
author: "NM"
date: "2026-01-27"
output: html_document
---

## 1.0 Load libraries 

```{r include=FALSE}
library(nanoparquet)
library(tidyverse)
library(openxlsx)
library(stringi)
library(janitor)
library(uuid)
```

## 2.0 Load data

```{r include=FALSE}
# -------- Paths to exported data files --------
data_dir <- "C:/Users/nmei0013/Downloads"
f_forms <- file.path(data_dir, "export-export_forms_empress_domain_20260127103959.parquet")
f_events <- file.path(data_dir, "export-export_events_empress_platform_20260127104411.parquet")
allocation <- file.path(data_dir, "export-export_allocations_empress_domain_20260123110315.parquet")

# -------- Load data from parquet files --------
EMPRESS_forms <- read_parquet(f_forms)
EMPRESS_events <- read_parquet(f_events)
EMPRESS_allocation <- read_parquet(allocation)
```

## 3.0 Creation of master dataframe for analysis

```{r}
EMPRESS_master_feasibility <- EMPRESS_events %>%
  mutate(
    ssid = as.character(ssid),
    timestamp = ymd_hms(timestamp)
  ) %>%
  filter(str_detect(event_type_name, "enrolment")) %>%
  group_by(ssid) %>%
  summarise(
    rand_datetime_utc = min(timestamp, na.rm = TRUE),
    enrolment_site    = dplyr::first(enrolment_site),
    .groups = "drop"
  ) %>%
  arrange(rand_datetime_utc) %>%
  slice_head(n = 200) %>%
  mutate(rand_datetime_local = with_tz(rand_datetime_utc, "Europe/Copenhagen")) %>%
  select(ssid, enrolment_site, rand_datetime_utc)
```

### 4.1 Addition of feasibility variables

```{r}
# --------------------------------------------------
# 1) Create one row per ssid with event indicators + created_at + time of death (tod)
# --------------------------------------------------
event_flags <- EMPRESS_events %>%
  mutate(
    ssid = as.character(ssid),
    event_type_name = as.character(event_type_name),
    data_collection_allowed = as.character(data_collection_allowed),
    timestamp = ymd_hms(timestamp),
    created_at = ymd_hms(created_at)   # <-- from EMPRESS_events
  ) %>%
  group_by(ssid) %>%
  summarise(
    # TRUE if the participant ever died
    death = any(event_type_name == "death", na.rm = TRUE),

    # created_at (earliest per ssid)  <-- added right after death as requested
    created_at = {
      ca <- created_at[event_type_name == "death"]
      if (length(ca) == 0 || all(is.na(ca))) {
        as.POSIXct(NA)
        } else {
          min(ca, na.rm = TRUE)
          }
      },

    # Time of death (earliest death timestamp)
    tod = {
      death_ts <- timestamp[event_type_name == "death"]
      if (length(death_ts) == 0 || all(is.na(death_ts))) {
        as.POSIXct(NA)
      } else {
        min(death_ts, na.rm = TRUE)
      }
    },

    # TRUE if the participant ever withdrew consent
    withdrawn_consent_empress = any(
      event_type_name == "withdrawn_consent_empress",
      na.rm = TRUE
    ),

    # Data collection allowed logic
    data_collection_allowed = {
      if (!withdrawn_consent_empress) {
        TRUE   # never withdrew → data collection allowed
      } else {
        dca <- data_collection_allowed[
          event_type_name == "withdrawn_consent_empress"
        ]

        if (length(dca) == 0) {
          NA
        } else if (any(dca == "yes", na.rm = TRUE)) {
          TRUE
        } else if (all(is.na(dca))) {
          NA
        } else {
          FALSE
        }
      }
    },

    .groups = "drop"
  )

# --------------------------------------------------
# 1b) Pull 30–90d follow-up variables from EMPRESS_forms
#     (pick the form row with the earliest start_datetime per ssid)
# --------------------------------------------------
followup_30_90 <- EMPRESS_forms %>%
  mutate(
    ssid = as.character(ssid),
    start_datetime = ymd_hms(start_datetime)
  ) %>%
  filter(form_layout == "empress_30_90_days_followup") %>%
  group_by(ssid) %>%
  slice_min(start_datetime, with_ties = FALSE) %>%
  ungroup() %>%
  transmute(
    ssid,
    followup_30 = case_when(
      value == "Yes" ~ TRUE,
      value == "No"  ~ FALSE,
      TRUE           ~ NA
    ),
    first_value_change,
    latest_value_change
  )

# --------------------------------------------------
# 2) Join indicators to feasibility master (+ follow-up variables)
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(event_flags, by = "ssid") %>%
  left_join(followup_30_90, by = "ssid") %>%
  mutate(
    death = coalesce(death, FALSE),
    withdrawn_consent_empress = coalesce(withdrawn_consent_empress, FALSE)
    # NOTE: data_collection_allowed intentionally NOT coalesced
  )

# --------------------------------------------------
# 3) Calculation of retention 
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(
    # ensure proper datetime classes (safe even if already POSIXct)
    rand_datetime_utc   = ymd_hms(rand_datetime_utc),
    first_value_change  = ymd_hms(first_value_change),
    latest_value_change = ymd_hms(latest_value_change),

    # days (including hh:mm:ss) from randomisation to first_value_change
    days_retention = as.numeric(difftime(first_value_change, rand_datetime_utc, units = "days")),

    # retention flag
    retention = case_when(
      is.na(days_retention)        ~ NA,      # keep missing if no follow-up timestamp
      days_retention <= 45         ~ TRUE,
      days_retention > 45          ~ FALSE
    )
  ) %>%
  relocate(days_retention, retention, .after = latest_value_change)
```


```{r}
# --------------------------------------------------
# 1) Create one row per ssid with event indicators + time of death (tod)
# --------------------------------------------------
event_flags <- EMPRESS_events %>%
  mutate(
    ssid = as.character(ssid),
    event_type_name = as.character(event_type_name),
    data_collection_allowed = as.character(data_collection_allowed),
    timestamp = ymd_hms(timestamp)
  ) %>%
  group_by(ssid) %>%
  summarise(
    # TRUE if the participant ever died
    death = any(event_type_name == "death", na.rm = TRUE),

    # Time of death (earliest death timestamp)
    tod = {
      death_ts <- timestamp[event_type_name == "death"]
      if (length(death_ts) == 0 || all(is.na(death_ts))) {
        as.POSIXct(NA)
      } else {
        min(death_ts, na.rm = TRUE)
      }
    },

    # TRUE if the participant ever withdrew consent
    withdrawn_consent_empress = any(
      event_type_name == "withdrawn_consent_empress",
      na.rm = TRUE
    ),

    # Data collection allowed logic
    data_collection_allowed = {
      if (!withdrawn_consent_empress) {
        TRUE   # never withdrew → data collection allowed
      } else {
        dca <- data_collection_allowed[
          event_type_name == "withdrawn_consent_empress"
        ]

        if (length(dca) == 0) {
          NA
        } else if (any(dca == "yes", na.rm = TRUE)) {
          TRUE
        } else if (all(is.na(dca))) {
          NA
        } else {
          FALSE
        }
      }
    },

    .groups = "drop"
  )

# --------------------------------------------------
# 2) Join indicators to feasibility master
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(event_flags, by = "ssid") %>%
  mutate(
    death = coalesce(death, FALSE),
    withdrawn_consent_empress = coalesce(withdrawn_consent_empress, FALSE)
    # NOTE: data_collection_allowed intentionally NOT coalesced
  )

# --------------------------------------------------
# 3) Add treatment allocation  (DUMMY: random 50/50 per ssid)
# --------------------------------------------------
set.seed(20260127)

# Create a dummy allocation table for the current feasibility cohort (one row per ssid)
# NOTE: allocated_arm values MUST match what your downstream logic expects:
#       "meropenem" and "piperacillin/tazobactam"
EMPRESS_allocation <- EMPRESS_master_feasibility %>%
  distinct(ssid) %>%
  mutate(ssid = as.character(ssid)) %>%
  {
    n <- nrow(.)
    arms <- c(
      rep("meropenem", n %/% 2),
      rep("piperacillin/tazobactam", n - (n %/% 2))
    )
    mutate(., allocated_arm = sample(arms, size = n, replace = FALSE))
  }

# Join allocation onto forms (row-level) and master (participant-level) as before
EMPRESS_forms_allocation <- EMPRESS_forms %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    EMPRESS_allocation %>%
      select(ssid, allocated_arm),
    by = "ssid"
  )

EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    EMPRESS_allocation %>%
      select(ssid, allocated_arm),
    by = "ssid"
  )

# --------------------------------------------------
# 4) Identify protocol violations at the row level
# --------------------------------------------------
participants_with_violation <- EMPRESS_forms_allocation %>%
  # Only rows that could possibly generate a violation
  filter(
    value %in% c("By error", "Other reason(s)") |
      (variable_name == "other_antibiotic_agent_than_allocated_type_agent" &
         !is.na(value) & value != "")
  ) %>%
  mutate(
    # Rule 1: explicit protocol deviation reason
    v_reason = value %in% c("By error", "Other reason(s)"),

    # Rule 2: non-allocated antibiotic used (string matching; handles multi-values)
    v_nonallocated =
      (allocated_arm == "meropenem" &
         str_detect(
           value,
           fixed("Beta-lactam/beta-lactamase inhibitor", ignore_case = TRUE)
         )) |
      (allocated_arm == "piperacillin/tazobactam" &
         str_detect(
           value,
           fixed("Carbapenem (e.g., meropenem)", ignore_case = TRUE)
         )),

    protocol_violation_row = v_reason | v_nonallocated
  ) %>%
  distinct(ssid, observation_id, .keep_all = TRUE) %>%
  group_by(ssid) %>%
  summarise(
    protocol_violation   = any(protocol_violation_row, na.rm = TRUE),
    protocol_violation_n = sum(protocol_violation_row %in% TRUE, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  # --------------------------------------------------
  # Bring back ALL participants
  # --------------------------------------------------
  right_join(
    EMPRESS_master_feasibility %>%
      distinct(ssid, allocated_arm),
    by = "ssid"
  ) %>%
  mutate(
    protocol_violation   = replace_na(protocol_violation, FALSE),
    protocol_violation_n = replace_na(protocol_violation_n, 0L),
    allocation = allocated_arm
  ) %>%
  select(ssid, allocation, protocol_violation, protocol_violation_n)

# --------------------------------------------------
# 6) Join protocol violation status
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  left_join(
    participants_with_violation %>%
      select(ssid, protocol_violation, protocol_violation_n),
    by = "ssid"
  )

rm(
  event_flags,
  participants_with_violation,
  EMPRESS_forms_allocation
)

```

### 4.2 Addition of baseline variables

```{r}
# --------------------------------------------------
# 1) Keep baseline, screening and follow-up forms only
# --------------------------------------------------
EMPRESS_forms_baseline <- EMPRESS_forms %>%
  filter(form_layout %in% c(
    "empress_baseline",
    "empress_domain_screening",
    "empress_30_90_days_followup"
  ))

# --------------------------------------------------
# 2) Identify duplicated variables per participant
# --------------------------------------------------
dups <- EMPRESS_forms_baseline %>%
  summarise(n = n(), .by = c(ssid, variable_name)) %>%
  filter(n > 1L)

# --------------------------------------------------
# 3a) Convert NON-microbiology baseline data from long to wide format
# --------------------------------------------------
EMPRESS_forms_baseline_wide <- EMPRESS_forms_baseline %>%
  filter(!variable_name %in% c(
    "type_of_sample",
    "type_of_bacteria",
    "resistance_to_piperacillin_tazobactam",
    "resistance_to_meropenem"
  )) %>%
  select(ssid, variable_name, value) %>%
  mutate(
    ssid  = as.character(ssid),
    value = na_if(trimws(as.character(value)), "")
  ) %>%
  pivot_wider(
    names_from  = variable_name,
    values_from = value,
    values_fn   = ~ dplyr::first(na.omit(.x)),
    values_fill = NA_character_
  )

# --------------------------------------------------
# 3b) Extract 30_90_day_followup value + first_value_change (long -> 1 row/ssid)
# --------------------------------------------------
followup_lookup <- EMPRESS_forms_baseline %>%
  filter(variable_name == "30_90_day_followup") %>%
  transmute(
    ssid                 = as.character(ssid),
    `30_90_day_followup` = na_if(trimws(as.character(value)), ""),
    first_value_change   = first_value_change
  ) %>%
  group_by(ssid) %>%
  summarise(
    `30_90_day_followup` = dplyr::first(na.omit(`30_90_day_followup`)),
    first_value_change   = dplyr::first(na.omit(first_value_change)),
    .groups = "drop"
  )

# --------------------------------------------------
# 3c) Join followup info to feasibility master and place columns after tod
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(followup_lookup, by = "ssid") %>%
  relocate(`30_90_day_followup`, first_value_change, .after = tod)

# --------------------------------------------------
# 4) Create baseline_bacterial_cultures in LONG format
# --------------------------------------------------
baseline_bacterial_cultures <- EMPRESS_forms_baseline %>%
  filter(variable_name %in% c(
    "type_of_sample",
    "type_of_bacteria",
    "resistance_to_piperacillin_tazobactam",
    "resistance_to_meropenem",
    "positive_bacterial_culture"
  )) %>%
  transmute(
    ssid = as.character(ssid),
    childset_group = as.character(childset_group),
    parent_observation_id = as.character(parent_observation_id),
    variable = factor(
      variable_name,
      levels = c(
        "type_of_sample",
        "type_of_bacteria",
        "resistance_to_piperacillin_tazobactam",
        "resistance_to_meropenem",
        "positive_bacterial_culture"
      )
    ),
    value = na_if(trimws(as.character(value)), "")
  ) %>%
  filter(!is.na(value)) %>%
  arrange(
    ssid,
    desc(is.na(childset_group)),  # NA childset_group FIRST (master row)
    childset_group,               # then sort by childset_group
    variable                       # then your enforced variable order
  )

# --------------------------------------------------
# 5) Baseline variables + bacterial flag to feasibility master
# --------------------------------------------------
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = as.character(ssid)) %>%
  left_join(
    EMPRESS_forms_baseline_wide %>%
      select(
        ssid,
        date_of_birth,
        sex,
        weight,
        height,
        ischemic_heart_disease,
        diabetes,
        chronic_pulmonary_disease,
        haematological_or_metastatic_cancer,
        immunosuppression,
        organ_transplantation,
        chronic_rrt,
        chronic_liver_disease,
        clinical_frailty_scale,
        limitations_of_care,
        date_of_index_hospital_admission,
        department_at_which_the_participant_was_included,
        acute_surgical_admission,
        primary_site_of_infection,
        positive_bacterial_culture,
        use_of_respiratory_support_at_randomisation,
        type_of_respiratory_support,
        fio2_before_randomisation,
        max_oxygen_flow_at_randomisation,
        arterial_blood_gas_available,
        arterial_oxygen_saturation,
        pao2,
        peripheral_oxygen_saturation,
        systolic_blood_pressure_lowest,
        lactate_highest,
        creatinine_highest,
        use_of_circulatory_support_at_randomisation,
        rrt_within_72h_before_randomisation,
        treatment_with_antibacterial_agent_prior_to_randomisation,
        anti_bacterial_agent
      ),
    by = "ssid"
  ) 

rm(
  dups,
  EMPRESS_forms_baseline,
  EMPRESS_forms_baseline_wide, 
  followup_lookup
)
```

### 4.3 Addition of dayform variables

```{r}
# ==================================================
# 0) Constants / variable sets used throughout
# ==================================================
max_dayforms <- 90L

trial_layout_1_30     <- "empress_dayform_1_to_30"
non_trial_layout_1_30 <- "empress_dayform_non_trial_site_1_to_30"

trial_layout_1_90     <- "empress_dayform_1_to_90"
non_trial_layout_1_90 <- "empress_dayform_non_trial_site_1_to_90"

dayform_layouts <- c(
  trial_layout_1_30, non_trial_layout_1_30,
  trial_layout_1_90, non_trial_layout_1_90
)

# Variables allowed on days 31–90 (ONLY)
vars_31_90_only <- c(
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day"
)

# Dayform variables (trial stream should have all of these)
dayform_vars_all <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "reason_for_not_receiving_at_least_50_percent",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent"
)

# Non-trial stream should only have the "first 10"
dayform_vars_non_trial <- c(
  "isolation_due_to_resistant_bacteria",
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis"
)

# dosing_regimen only comes from empress_dayform_1 (not in 1–30 layouts)
single_vars <- c("dosing_regimen")

# Ordering of variables in long-format output
var_order_full <- c(dayform_vars_all, "dosing_regimen")

# Variable types (for reduction rules)
bool_vars <- c(
  "isolation_due_to_resistant_bacteria",
  "invasive_mechanical_ventilation",
  "circulatory_support_min_1h",
  "any_rrt_this_day",
  "anaphylactic_shock_piptazo_meropenem",
  "invasive_fungal_infection",
  "pseudomembranous_colitis",
  "toxic_epidermal_necrolysis",
  "did_the_patient_receive_at_least_50percent_of_the_prescribed_daily_dose",
  "use_of_any_another_antibiotic_agent_than_allocated_on_this_day"
)

multi_vars <- c(
  "type_of_resistant_bacteria_new",
  "antibiotic_agent_to_which_the_bacteria_was_resistant",
  "reason_for_not_receiving_at_least_50_percent",
  "other_antibiotic_agent_than_allocated_type_treatment",
  "other_antibiotic_agent_than_allocated_type_agent"
)

# Separators used for merges
sep_multi_stream <- " || "   # between trial and non_trial within transfer-days
sep_multi_within <- "__"     # within-stream de-dup concatenation (keeps existing style)

# Helpers
na_blank <- function(x) {
  x <- str_squish(as.character(x))
  x[x %in% c("", "NA", "NaN")] <- NA_character_
  x
}

to_bool <- function(x) {
  x <- str_to_lower(str_squish(as.character(x)))
  case_when(
    x %in% c("true", "t", "yes", "1")  ~ TRUE,
    x %in% c("false","f","no","0")     ~ FALSE,
    TRUE                              ~ NA
  )
}

tz_local <- "Europe/Copenhagen"
day_start_hour <- 6

utc_to_local_inplace <- function(x, tz_local = "Europe/Copenhagen") {
  # If POSIXct: first treat as UTC instant (no clock shift), then display in local
  if (inherits(x, "POSIXct")) {
    x_utc <- lubridate::force_tz(x, tzone = "UTC")
    return(lubridate::with_tz(x_utc, tzone = tz_local))
  }

  # If character: parse as UTC, then display in local
  x_utc <- suppressWarnings(lubridate::parse_date_time(
    as.character(x),
    orders = c("Ymd HMS","Ymd HM","Y-m-d HMS","Y-m-d HM"),
    tz = "UTC"
  ))
  lubridate::with_tz(x_utc, tzone = tz_local)
}

# ==================================================
# QC helper (optional): participants with both trial + non-trial dayform streams
# ==================================================
test_both_streams <- EMPRESS_forms %>%
  filter(form_layout %in% dayform_layouts) %>%
  mutate(start_datetime = ymd_hms(start_datetime)) %>%
  count(ssid, form_layout) %>%
  filter(n > 1) %>%
  arrange(ssid)

# ==================================================
# 1A) Subset relevant forms
# ==================================================
EMPRESS_forms_dayform_subset <- EMPRESS_forms %>%
  filter(
    (form_layout == "empress_dayform_1" & variable_name %in% single_vars) |
      (form_layout %in% dayform_layouts & variable_name %in% dayform_vars_all)
  ) %>%
  mutate(
    ssid = as.character(ssid),
    start_datetime = utc_to_local_inplace(start_datetime, tz_local = tz_local),
    end_datetime   = utc_to_local_inplace(end_datetime,   tz_local = tz_local)
  )

# ==================================================
# 1B) Randomization reference (rand_time) per ssid
#     - ensure ONE row per ssid
#     - treat rand_datetime_utc as UTC, convert to local before day boundary
# ==================================================
rand0 <- EMPRESS_master_feasibility %>%
  mutate(
    ssid = stringr::str_squish(as.character(ssid)),

    # Parse/standardize: treat source as UTC, then convert to local
    rand_datetime_utc = {
      x <- rand_datetime_utc
      if (!inherits(x, "POSIXct")) x <- lubridate::ymd_hms(x, tz = "UTC")
      lubridate::force_tz(x, tzone = "UTC")
    },
    rand_datetime_local = lubridate::with_tz(rand_datetime_utc, tzone = tz_local),

    # IMPORTANT: compute day in LOCAL tz explicitly
    random_day0 = lubridate::as_date(
      rand_datetime_local - lubridate::hours(day_start_hour),
      tz = tz_local
    )
  ) %>%
  group_by(ssid) %>%
  summarise(
    rand_datetime_utc   = min(rand_datetime_utc, na.rm = TRUE),
    rand_datetime_local = min(rand_datetime_local, na.rm = TRUE),
    random_day0         = min(random_day0, na.rm = TRUE),
    .groups = "drop"
  )

# ==================================================
# 2A) Create stream + clinical day and assign
#     dayform_number as DAYS SINCE RANDOMIZATION
# ==================================================
EMPRESS_forms_dayform_subset_ordered <- EMPRESS_forms_dayform_subset %>%
  mutate(
    ssid = stringr::str_squish(as.character(ssid)),

    # IMPORTANT: compute clinical day in LOCAL tz explicitly
    clinical_day = lubridate::as_date(
      start_datetime - lubridate::hours(day_start_hour),
      tz = tz_local
    ),

    stream = dplyr::case_when(
      form_layout %in% c(trial_layout_1_30, trial_layout_1_90) ~ "trial",
      form_layout %in% c(non_trial_layout_1_30, non_trial_layout_1_90) ~ "non_trial",
      form_layout == "empress_dayform_1" ~ "trial",
      TRUE ~ NA_character_
    ),
    stream = factor(
      stringr::str_to_lower(stringr::str_squish(stream)),
      levels = c("trial", "non_trial")
    ),

    variable_name = factor(as.character(variable_name), levels = var_order_full),

    responsible_site = stringr::str_to_lower(
      stringr::str_squish(as.character(responsible_site))
    ),

    layout_priority = dplyr::case_when(
      form_layout %in% c(trial_layout_1_30, non_trial_layout_1_30) ~ 1L,
      form_layout %in% c(trial_layout_1_90, non_trial_layout_1_90) ~ 2L,
      TRUE ~ 99L
    )
  ) %>%
  left_join(rand0, by = "ssid") %>%
  mutate(
    dayform_number = as.integer(clinical_day - random_day0) + 1L,
    form_number    = paste0("dayform_", dayform_number)
  ) %>%
  filter(
    !is.na(dayform_number),
    dayform_number >= 1L,
    dayform_number <= max_dayforms,

    # 1_to_90 layouts only contribute the 3 vars
    !(form_layout %in% c(trial_layout_1_90, non_trial_layout_1_90) &
        !(as.character(variable_name) %in% vars_31_90_only))
  ) %>%
  arrange(ssid, dayform_number, layout_priority, start_datetime, variable_name) %>%
  ungroup() %>%
  select(-clinical_day) %>%
  relocate(form_number, .after = ssid)

# ==================================================
# 2B) Day existence flags: dayform_real_1 ... dayform_real_30
#     TRUE  = day exists in the export (at least one record that day)
#     FALSE = no exported records for that day (will be all-NA later)
# ==================================================
dayform_real_flags <- EMPRESS_forms_dayform_subset_ordered %>%
  mutate(
    day_num = as.integer(str_extract(form_number, "(?<=dayform_)\\d+"))
  ) %>%
  distinct(ssid, day_num) %>%
  mutate(dayform_real = TRUE) %>%
  tidyr::complete(ssid, day_num = 1:max_dayforms, fill = list(dayform_real = FALSE)) %>%
  mutate(flag_name = paste0("dayform_real_", day_num)) %>%
  select(ssid, flag_name, dayform_real) %>%
  tidyr::pivot_wider(
    names_from = flag_name,
    values_from = dayform_real,
    values_fill = FALSE
  )

# ==================================================
# 3) Fill missing variables per ssid + form_number + stream
#    - trial stream gets ALL 15 dayform vars
#    - non_trial stream gets first 10 only
#    - only applied for stream days that exist (no synthetic streams created)
# ==================================================
# Which stream-days exist?
stream_days <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  distinct(ssid, form_number, dayform_number, stream)

# Expected variable grid for existing stream-days
expected_trial <- stream_days %>%
  filter(stream == "trial") %>%
  tidyr::crossing(variable_name = dayform_vars_all) %>%
  # On days 31–90, keep ONLY the 3 variables
  filter(dayform_number <= 30L | variable_name %in% vars_31_90_only)

expected_non_trial <- stream_days %>%
  filter(stream == "non_trial") %>%
  tidyr::crossing(variable_name = dayform_vars_non_trial) %>%
  # On days 31–90, keep ONLY the 3 variables
  filter(dayform_number <= 30L | variable_name %in% vars_31_90_only)

expected_all <- bind_rows(expected_trial, expected_non_trial) %>%
  transmute(
    ssid = as.character(ssid),
    form_number,
    stream = as.character(stream),
    variable_name = as.character(variable_name)
  )

# Existing keys
existing_keys <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  transmute(
    ssid = as.character(ssid),
    form_number,
    stream = as.character(stream),
    variable_name = as.character(variable_name)
  ) %>%
  distinct()

# Identify missing rows to create
missing_rows_keys <- expected_all %>%
  anti_join(existing_keys, by = c("ssid", "form_number", "stream", "variable_name"))

# Template (1 row per ssid + form_number + stream) to copy metadata
template_cols <- EMPRESS_forms_dayform_subset_ordered %>%
  filter(stream %in% c("trial", "non_trial")) %>%
  group_by(ssid, form_number, stream) %>%
  slice(1) %>%
  ungroup() %>%
  select(-variable_name, -value)

# Build missing rows with NA values
missing_rows_full <- missing_rows_keys %>%
  left_join(template_cols, by = c("ssid", "form_number", "stream")) %>%
  mutate(
    variable_name = as.character(variable_name),
    value = NA_character_
  )

# Bind back and order deterministically
EMPRESS_forms_dayform_filled <- bind_rows(
  EMPRESS_forms_dayform_subset_ordered,
  missing_rows_full
) %>%
  mutate(
    day_num = as.integer(str_extract(form_number, "(?<=dayform_)\\d+")),
    variable_name = factor(as.character(variable_name), levels = var_order_full)
  ) %>%
  arrange(ssid, day_num, stream, variable_name, start_datetime) %>%  # start_datetime is now local
  select(-day_num)

# ==================================================
# 4) Merge trial/non-trial within same dayform (transfer-days)
#    - merge_this_day: TRUE if both streams exist in the same ssid+form_number
# ==================================================
merge_map <- EMPRESS_forms_dayform_filled %>%
  filter(stream %in% c("trial","non_trial")) %>%
  group_by(ssid, form_number) %>%
  summarise(
    n_streams = n_distinct(stream),

    # distinct sites within each stream-day
    n_sites_trial = n_distinct(responsible_site[stream == "trial" & !is.na(responsible_site)]),
    n_sites_nontrial = n_distinct(responsible_site[stream == "non_trial" & !is.na(responsible_site)]),

    # merge if transfer OR same-stream split across sites
    merge_this_day = (n_streams > 1) | (n_sites_trial > 1) | (n_sites_nontrial > 1),
    .groups = "drop"
  ) %>%
  select(ssid, form_number, merge_this_day)

df <- EMPRESS_forms_dayform_filled %>%
  left_join(merge_map, by = c("ssid","form_number")) %>%
  mutate(merge_this_day = coalesce(merge_this_day, FALSE))

# ==================================================
# 5) Reduce boolean variables within each ssid + form_number
#    - TRUE overrides FALSE; otherwise FALSE; otherwise NA
# ==================================================
day_bool <- df %>%
  filter(as.character(variable_name) %in% bool_vars) %>%
  mutate(val_bool = to_bool(value)) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = dplyr::case_when(
      any(val_bool %in% TRUE,  na.rm = TRUE) ~ "TRUE",
      any(val_bool %in% FALSE, na.rm = TRUE) ~ "FALSE",
      TRUE                                   ~ NA_character_
    ),
    .groups = "drop"
  )

# ==================================================
# 6) Reduce multi-value variables
#    A) Not transfer-days: keep first value by time (may be NA)
#    B) Transfer-days: merge trial + non_trial within dayform
#       - within each stream: de-duplicate repeated identical values (keeps first occurrence)
#       - between streams: combine with " || "
#       - CURRENT behavior is "lenient": keep available stream if the other is NA
# ==================================================
# Helper to collapse values within a group (unique, keep order)
collapse_unique <- function(x, sep = "__") {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_character_)
  x <- x[!duplicated(x)]
  paste(x, collapse = sep)
}

df_multi <- df %>% 
  filter(as.character(variable_name) %in% multi_vars) %>%
  mutate(
    value  = na_blank(value),

    # IMPORTANT: enforce exact stream names used in pivot
    stream = case_when(
      as.character(stream) %in% c("trial")      ~ "trial",
      as.character(stream) %in% c("non_trial")  ~ "non_trial",
      as.character(stream) %in% c("nontrial")   ~ "non_trial",  # safety
      TRUE ~ NA_character_
    )
  )

# A) Not split days
day_multi_not_merged <- df_multi %>%
  filter(!merge_this_day) %>%
  arrange(ssid, form_number, variable_name, layout_priority, start_datetime) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(value = dplyr::first(value), .groups = "drop")

# B1) Split days: merge within stream
day_multi_split_stream <- df_multi %>%
  filter(merge_this_day) %>%
  arrange(ssid, form_number, variable_name, stream, layout_priority, start_datetime) %>%
  group_by(ssid, form_number, variable_name, stream) %>%
  summarise(v_stream = collapse_unique(value, sep = sep_multi_within), .groups = "drop")

# B2) Combine streams
# helper: ensure columns exist (create as NA if missing)
ensure_cols <- function(df, cols, fill = NA_character_) {
  missing <- setdiff(cols, names(df))
  if (length(missing) > 0) {
    df[missing] <- fill
  }
  df
}

day_multi_merged <- day_multi_split_stream %>%
  tidyr::pivot_wider(
    names_from  = stream,
    values_from = v_stream,
    values_fill = NA_character_
  ) %>%
  ensure_cols(c("trial", "non_trial"), fill = NA_character_) %>%  # <--- key line
  mutate(
    value = dplyr::case_when(
      !is.na(trial) & !is.na(non_trial) ~ paste(trial, non_trial, sep = sep_multi_stream),
      !is.na(trial)                    ~ trial,
      !is.na(non_trial)                ~ non_trial,
      TRUE                             ~ NA_character_
    )
  ) %>%
  select(ssid, form_number, variable_name, value)

day_multi_long <- dplyr::bind_rows(day_multi_not_merged, day_multi_merged)

# ==================================================
# 7) Reduce single-value variable(s): dosing_regimen
# ==================================================
day_single <- df %>%
  filter(as.character(variable_name) %in% single_vars) %>%
  mutate(v = na_if(str_squish(as.character(value)), "")) %>%
  group_by(ssid, form_number, variable_name) %>%
  summarise(
    value = dplyr::first(na.omit(v)),
    .groups = "drop"
  )

# ==================================================
# 8) Combine all reduced outputs, then pivot wide (1 row per ssid)
# ==================================================
day_merged_long <- bind_rows(day_bool, day_multi_long, day_single) %>%
  mutate(
    ssid  = as.character(ssid),
    value = as.character(value),
    var_day = paste0(form_number, "__", as.character(variable_name))
  ) %>%
  select(ssid, var_day, value)

EMPRESS_dayforms_wide_1row <- day_merged_long %>%
  pivot_wider(
    id_cols     = ssid,
    names_from  = var_day,
    values_from = value,
    values_fn   = ~ dplyr::first(na.omit(.x)),
    values_fill = NA_character_
  )

# ==================================================
# 9) Force expected wide columns (dayforms 1–30; dosing_regimen day 1 only)
#    - Force ALL dayform_vars_all for all days + dosing_regimen for day 1
# ==================================================
expected_cols <- c(
  # Days 1–30: full variable set
  expand_grid(var_nm = dayform_vars_all, day_num = 1:30) %>%
    mutate(col = paste0("dayform_", day_num, "__", var_nm)) %>%
    pull(col),

  # Days 31–90: only the 3 variables
  expand_grid(var_nm = vars_31_90_only, day_num = 31:max_dayforms) %>%
    mutate(col = paste0("dayform_", day_num, "__", var_nm)) %>%
    pull(col),

  "dayform_1__dosing_regimen"
)

missing_cols <- setdiff(expected_cols, names(EMPRESS_dayforms_wide_1row))

if (length(missing_cols) > 0) {
  EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
    tibble::add_column(!!!setNames(rep(list(NA_character_), length(missing_cols)), missing_cols))
}

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  select(ssid, all_of(expected_cols))

# ==================================================
# 10) Reorder wide columns by VARIABLE (dayform_vars_all order) then Dayform number (1–30)
#     - dosing_regimen only exists on day 1; placed after the 15 dayform_vars_all by default
# ==================================================
var_order_wide <- c(dayform_vars_all, "dosing_regimen")

dayform_cols <- names(EMPRESS_dayforms_wide_1row) %>%
  setdiff("ssid") %>%
  tibble(col = .) %>%
  mutate(
    day_num  = as.integer(str_extract(col, "(?<=dayform_)\\d+")),
    var_nm   = str_replace(col, "^dayform_\\d+__", ""),
    var_rank = match(var_nm, var_order_wide)
  ) %>%
  # push anything unexpected to the end 
  mutate(
    var_rank = if_else(is.na(var_rank), 9999L, var_rank),
    day_num  = if_else(is.na(day_num), 9999L, day_num)
  ) %>%
  arrange(var_rank, day_num, col) %>%
  pull(col)

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  mutate(ssid = str_squish(as.character(ssid))) %>%
  select(ssid, all_of(dayform_cols))

# ==================================================
# 10B) Add dayform_real_* flags to the wide dayform dataset (robust)
#      - ensure ssid matches (trim)
#      - convert any NA flags to FALSE (in case of non-matching ssid)
# ==================================================
dayform_real_cols <- paste0("dayform_real_", 1:max_dayforms)

EMPRESS_dayforms_wide_1row <- EMPRESS_dayforms_wide_1row %>%
  left_join(
    dayform_real_flags %>%
      mutate(ssid = str_squish(as.character(ssid))),
    by = "ssid"
  ) %>%
  mutate(
    across(any_of(dayform_real_cols), ~ replace_na(.x, FALSE))
  )

# ==================================================
# 11) Join to feasibility master (must happen BEFORE relocate)
# ==================================================
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  mutate(ssid = stringr::str_squish(as.character(ssid))) %>%
  left_join(EMPRESS_dayforms_wide_1row, by = "ssid") %>%
  # extra safety: ensure flags are not NA after the join
  mutate(
    across(dplyr::any_of(dayform_real_cols), ~ tidyr::replace_na(.x, FALSE))
  )

# ==================================================
# 11B) Reorder columns: place dayform_real_1..30 right after anti_bacterial_agent
#      - use any_of() to avoid errors if something is missing
# ==================================================
EMPRESS_master_feasibility <- EMPRESS_master_feasibility %>%
  dplyr::relocate(dplyr::any_of(dayform_real_cols), .after = anti_bacterial_agent)

# ==================================================
# Cleanup (optional)
# ==================================================
rm(
  EMPRESS_forms_dayform_subset,
  EMPRESS_forms_dayform_subset_ordered,
  EMPRESS_forms_dayform_filled,
  missing_rows_keys,
  missing_rows_full,
  template_cols,
  expected_trial,
  expected_non_trial,
  expected_all,
  existing_keys,
  stream_days,
  merge_map,
  df,
  df_multi,
  day_bool,
  day_multi_not_merged,
  day_multi_merged,
  day_multi_long,
  day_single,
  day_merged_long,
  EMPRESS_dayforms_wide_1row,
  dayform_real_flags
)
```

```{r}
cols_with_pipes <- EMPRESS_master_feasibility %>%
  summarise(
    across(
      where(is.character),
      ~ any(str_detect(.x, fixed("||")), na.rm = TRUE)
    )
  ) %>%
  pivot_longer(everything(),
               names_to = "column",
               values_to = "contains_pipes") %>%
  filter(contains_pipes)

cols_with_pipes
```
